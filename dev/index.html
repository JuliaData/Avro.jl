<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · Avro.jl</title><link rel="canonical" href="https://JuliaData.github.io/Avro.jl/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Avro.jl</span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaData/Avro.jl/blob/main/docs/src/index.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Avro"><a class="docs-heading-anchor" href="#Avro">Avro</a><a id="Avro-1"></a><a class="docs-heading-anchor-permalink" href="#Avro" title="Permalink"></a></h1><p>Documentation for <a href="https://github.com/JuliaData/Avro.jl">Avro</a>.</p><ul><li><a href="#Avro.Avro"><code>Avro.Avro</code></a></li><li><a href="#Avro.Table"><code>Avro.Table</code></a></li><li><a href="#Avro.parseschema-Tuple{Any}"><code>Avro.parseschema</code></a></li><li><a href="#Avro.read"><code>Avro.read</code></a></li><li><a href="#Avro.readtable"><code>Avro.readtable</code></a></li><li><a href="#Avro.tobuffer-Tuple{Any}"><code>Avro.tobuffer</code></a></li><li><a href="#Avro.write"><code>Avro.write</code></a></li><li><a href="#Avro.writetable"><code>Avro.writetable</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="Avro.Avro" href="#Avro.Avro"><code>Avro.Avro</code></a> — <span class="docstring-category">Module</span></header><section><div><p>The Avro.jl package provides a pure Julia implementation for reading writing data in the <a href="http://avro.apache.org/docs/current/spec.html">avro format</a>.</p><p><strong>Implementation status</strong></p><p>It currently supports:</p><ul><li>All primitive types</li><li>All nested/complex types</li><li>Logical types listed in the spec (Decimal, UUID, Date, Time, Timestamps, Duration)</li><li>Binary encoding/decoding</li><li>Reading/writing object container files via the Tables.jl interface</li><li>Supports the xz, zstd, deflate, and bzip2 compression codecs for object container files</li></ul><p>Currently not supported are:</p><ul><li>JSON encoding/decoding of objects</li><li>Single object encoding or schema fingerprints</li><li>Schema resolution</li><li>Protocol messages, calls, handshakes</li><li>Snappy compression</li></ul><p><strong>Package motivation</strong></p><p>Why use the avro format vs. other data formats? Some benefits include:</p><ul><li>Very concise binary encoding, especially object container files with compression</li><li>Very fast reading/writing</li><li>Objects/data must have well-defined schema</li><li>One of the few &quot;row-oriented&quot; binary data formats</li></ul><p><strong>Getting started</strong></p><p>The Avro.jl package supports two main APIs to interact with avro data. The first is similar to the JSON3.jl struct API for interacting with json data, largely in part due to the similarities between the avro format and json. This looks like:</p><pre><code class="language-julia">buf = Avro.write(obj)
obj = Avro.read(buf, typeof(obj))</code></pre><p>In short, we use <a href="#Avro.write"><code>Avro.write</code></a> and provide an object <code>obj</code> to write out in the avro format. We can optionally provide a filename or <code>IO</code> as a first argument to write the data to.</p><p>We can then read the data back in using <a href="#Avro.read"><code>Avro.read</code></a>, where the first argument must be a filename, <code>IO</code>, or any <code>AbstractVector{UInt8}</code> byte buffer containing avro data. The 2nd argument is <em>required</em>, and is the type of data to be read. This type can be provided as a simple Julia type (like <code>Avro.read(buf, Vector{String})</code>), or as a parsed avro schema, like <code>Avro.read(buf, Avro.parseschema(&quot;schema.avsc&quot;))</code>. <a href="#Avro.parseschema-Tuple{Any}"><code>Avro.parseschema</code></a> takes a filename or json string representing the avro schema of the data to read and returns a &quot;schema type&quot; that can be passed to <code>Avro.read</code>.</p><p>The second alternative API allows &quot;packaging&quot; the data&#39;s schema with the data in what the avro spec calls an &quot;object container&quot; file. While <code>Avro.read</code>/<code>Avro.write</code> require the user to already know or pass the schema externally, <a href="#Avro.writetable"><code>Avro.writetable</code></a> and <a href="#Avro.readtable"><code>Avro.readtable</code></a> can write/read avro object container files, and will take care of any schema writing/reading, compression, etc. automatically. These table functions unsurprisingly utilize the ubiquitous Tables.jl interface to facilitate integrations with other formats.</p><pre><code class="language-julia"># write our input_table out to a file named &quot;data.avro&quot; using the zstd compression codec
# input_table can be any Tables.jl-compatible source, like CSV.File, Arrow.Table, DataFrame, etc.
Avro.writetable(&quot;data.avro&quot;, input_table; compress=:zstd)

# we can also read avro data from object container files
# if file uses compression, it will be decompressed automatically
# the schema of the data is packaged in the object container file itself
# and will be parsed before constructing the file table
tbl = Avro.readtable(&quot;data.avro&quot;)
# the returned type is `Avro.Table`, which satisfies the Tables.jl interface
# which means it can be sent to any valid sink function, like
# Arrow.write(&quot;data.arrow&quot;, tbl), CSV.write(&quot;data.csv&quot;, tbl), or DataFrame(tbl)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/Avro.jl/blob/e523f8a618d2f5a53424c69405acfe493b3d3e1d/src/Avro.jl#L4-L82">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Avro.Table" href="#Avro.Table"><code>Avro.Table</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Avro.Table</code></pre><p>A Tables.jl-compatible source returned from <code>Avro.readtable</code>. Conceptually, it can be thought of as an <code>AbstractVector{Record}</code>, where <code>Record</code> is the avro version of a &quot;row&quot; or NamedTuple. Thus, <code>Avro.Table</code> supports indexing/iteration like an <code>AbstractVector</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/Avro.jl/blob/e523f8a618d2f5a53424c69405acfe493b3d3e1d/src/tables.jl#L121-L128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Avro.parseschema-Tuple{Any}" href="#Avro.parseschema-Tuple{Any}"><code>Avro.parseschema</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Avro.parseschema(file_or_jsonstring)</code></pre><p>Parse the avro schema in a file or raw json string. The schema is expected to follow the format as described in the official <a href="http://avro.apache.org/docs/current/spec.html#schemas">spec</a>. Returns a &quot;schema type&quot; that can be passed to <code>Avro.read(buf, sch)</code> as the 2nd argument.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/Avro.jl/blob/e523f8a618d2f5a53424c69405acfe493b3d3e1d/src/utils.jl#L60-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Avro.read" href="#Avro.read"><code>Avro.read</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Avro.read(source, T_or_sch) =&gt; T</code></pre><p>Read an avro-encoded object of type <code>T</code> or avro schema <code>sch</code> from <code>source</code>, which can be a byte buffer <code>AbstractVector{UInt8}</code>, file name <code>String</code>, or <code>IO</code>.</p><p>The data in <code>source</code> must be avro-formatted data, as no schema verification can be done. Note that &quot;avro object container files&quot; should be processed using <a href="#Avro.readtable"><code>Avro.readtable</code></a> instead, where the data schema is encoded in the file itself. Also note that the 2nd argument can be a Julia type like <code>Vector{String}</code>, or a valid <code>Avro.Schema</code> type object, like is returned from <code>Avro.parseschema(src)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/Avro.jl/blob/e523f8a618d2f5a53424c69405acfe493b3d3e1d/src/types/binary.jl#L42-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Avro.readtable" href="#Avro.readtable"><code>Avro.readtable</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Avro.readtable(file_or_io) =&gt; Avro.Table</code></pre><p>Read an avro object container file, returning an <a href="#Avro.Table"><code>Avro.Table</code></a> type, which is like an array of records, where each record follows the  schema encoded with the file. Any compression will be detected and decompressed automatically when reading.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/Avro.jl/blob/e523f8a618d2f5a53424c69405acfe493b3d3e1d/src/tables.jl#L146-L153">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Avro.tobuffer-Tuple{Any}" href="#Avro.tobuffer-Tuple{Any}"><code>Avro.tobuffer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Avro.tobuffer(tbl; kw...)</code></pre><p>Take a Tables.jl-compatible input <code>tbl</code> and call <code>Avro.writetable</code> with an <code>IOBuffer</code>, which is returned, with position at the beginning.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/Avro.jl/blob/e523f8a618d2f5a53424c69405acfe493b3d3e1d/src/utils.jl#L47-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Avro.write" href="#Avro.write"><code>Avro.write</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Avro.write([filename|io,] x::T; kw...)</code></pre><p>Write an object <code>x</code> of avro-supported type <code>T</code> in the avro format. If a file name is provided as a <code>String</code> as 1st argument, the avro data will be written out to disk. Similarly, an <code>IO</code> argument can be provided as 1st argument. If no destination 1st argument is provided, a byte buffer <code>Vector{UInt8}</code> will be returned with avro data written to it. Supported keyword arguments include:</p><ul><li><code>schema</code>: the type that should be used when encoding the object in</li></ul><p>the avro format; most common is providing a <code>Union{...}</code> type to write   the data out specifically as a &quot;union type&quot; instead of only the type of the object;   alternatively, a valid <code>Avro.Schema</code> can be passed, like the result of   <code>Avro.parseschema(src)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/Avro.jl/blob/e523f8a618d2f5a53424c69405acfe493b3d3e1d/src/types/binary.jl#L1-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Avro.writetable" href="#Avro.writetable"><code>Avro.writetable</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Avro.writetable(io_or_file, tbl; kw...)</code></pre><p>Write an input Tables.jl-compatible source table <code>tbl</code> out as an avro object container file. <code>io_or_file</code> can be a file name as a <code>String</code> or <code>IO</code> argument. If the input table supports <code>Table.partitions</code>, each partition will be written as a separate &quot;block&quot; in the container file.</p><p>Because avro data is strictly typed, if the input table doesn&#39;t have a well-defined schema (i.e. <code>Tables.schema(Tables.rows(tbl)) === nothing</code>), then <code>Tables.dictrowtable(Tables.rows(tbl))</code> will be called, which scans the input table, &quot;building up&quot; the schema based on types of values found in each row.</p><p>Compression is supported via the <code>compress</code> keyword argument, and can currently be one of <code>:zstd</code>, <code>:deflate</code>, <code>:bzip2</code>, or <code>:xz</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/Avro.jl/blob/e523f8a618d2f5a53424c69405acfe493b3d3e1d/src/tables.jl#L14-L30">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 14 September 2021 20:53">Tuesday 14 September 2021</span>. Using Julia version 1.6.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
